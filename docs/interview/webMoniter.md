---
title: 性能监控
date: 2025/03/24
author: senmu
---

## 什么是性能监控？

性能监控简单来说就是通过一个 SDK 进行零负担的监测网站运行的性能情况以及报错等等。

## 为什么要做性能监控？

性能监控旨在收集网页的性能信息，然后分析信息进行改进提升，最终提升用户留存率等等。

## 怎样做性能监控？

1. 定好需要统计的指标，例如（FP、FCP、CLS、INP等）
2. 写一个 SDK 进行指标的统计、收集、上报
   1. 可以参考 `web-vitals` 库
   2. 注意做好兜底等边缘情况
   3. 注意性能问题
3. 建设/使用第三方成熟的数据处理平台进行数据的维护
   1. 收集数据
   2. 清洗脏数据，但是注意不要丢掉，单独存放进行分析是否有价值
   3. 存储正常数据
   4. 通过监控平台展示

如果要做错误等回放功能，可以考虑 [`rrweb`](https://github.com/rrweb-io/rrweb?tab=readme-ov-file)

## FCP（首次有内容的绘制）指标

- 核心部分
  - 利用 [`PerformanceObserver`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver) API
  - 监测 `paint`
    - 对于 FCP，`entry.name` 为 `first-contentful-paint`
    - 对于 FP，`entry.name` 为 `first-paint`
  - 计算指标
  - 上报
- 处理边缘情况
  - 预渲染
  - 页面是 `hidden` 状态
  - bfCache

- 测量什么？(`value = FCP 事件发生的时间点 - 页面激活的时间点`)
  - 预渲染：「页面激活的时间点（`activationStart`）」是用户实际导航到页面的时刻
    - 时间 0ms：浏览器开始在后台预渲染页面 A
    - 时间 2000ms：预渲染完成，页面在后台准备就绪
    - 时间 5000ms：用户点击链接，导航到页面 A（此时 `activationStart` = 5000ms）
    - 时间 5100ms：首次内容绘制 (FCP) 发生
    - 结果：5100 - 5000 = 100
  - 非预渲染：等于 0（即导航开始时间）
- 如何上报？
  - 页面非 `hidden` 状态，「强制上报」
  - 从 `bfcache` 返回，重新计算，「强制上报」

## LCP（最大内容的绘制）指标

其实懂了上面的 FCP 这个指标也很容易理解，核心就三个步骤：

1. 创建 `handleEntries` 方法来处理 `entries`
   1. [什么是 `entries`？](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry)
   2. <https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType>
2. 使用 `PerformanceObserver` 监测 `largest-contentful-paint`
3. 处理好边缘情况，上报数据

与 FCP 不同的是，LCP 是一个多次采集的过程，终止条件在用户与页面发生交互或者页面 `hidden` 的情况，这时才会上报 LCP 统计的数据。

- 测量什么？（`value = LCP 事件发生的时间点 - 页面激活的时间点`）
  - 与 FCP 类似
- 何时上报？
  - 页面非 `hidden` 状态，「尝试上报」
  - 页面发生了状态改变并且为 `hidden` 状态，「强制上报」
  - 发生了用户交互，「强制上报」
  - 从 `bfcache` 返回，重新计算，「强制上报」

## CLS（累积偏移量）指标

> 监测 `layout-shift`

流程就不赘述了，来说下值得关注的部分：

1. 必须发生在 `onFCP` 之后
   1. 符合 `CrUX` 标准
   2. 更加符合用户体验
   3. 减少噪音
2. 使用「会话窗口」的算法来计算 CLS
   1. **分组**：把时间上接近的布局偏移归为一组（窗口）
   2. **计时**：一个窗口的总时长不超过5秒，相邻偏移间隔不超过1秒
   3. **取最大值**：最终报告所有窗口中分数最高的那个
3. 何时上报？
   1. 当前「会话窗口」累计的偏移量大于前面累计的最大偏移量「尝试上报」（如果没有设置`reportAllChanges`为`true`也不会上报）
      1. 聚焦最差的
   2. 页面是 `hidden` 状态，「强制上报」（不管是否设置`reportAllChanges`都会上报）
   3. `bfcache` 之后「尝试上报」（如果没有设置`reportAllChanges`为`true`也不会上报）
   4. 最后，就算没有满足以上条件也「尝试上报」（如果没有设置`reportAllChanges`为`true`也不会上报）

## TTFB（首字节返回时间）指标

> 从点击链接到服务器开始发送响应需要多长时间？

- 测量什么？
  - `TTFB = responseStart - activationStart`
- 何时上报？
  - 统计到第一个请求返回，立马强制上报
  - `bfcache` 之后，重制指标值，强制上报（因为从 `bfcache` 返回，无需请求接口，所以直接上报 0）

## INP（Interaction to Next Paint）指标

> 发生交互到下次绘制的时间

### 概述

INP 跟踪用户的点击、触摸和按键交互，保留最慢的10个交互作为候选，然后从中选择一个统计上显著的值（通常是第98百分位）作为最终指标。
这个值代表了页面响应用户交互的最差情况，同时排除了极端异常值的影响。

- 测量什么？
  - `交互延迟 = 输入处理时间 + 事件处理时间 + 渲染更新时间`
    - **输入处理**：浏览器处理原始输入事件（点击、按键等）
    - **事件处理**：JavaScript 执行相应的事件处理程序
    - **渲染更新**：浏览器计算布局、绘制并显示更新后的内容
  - 过滤掉延迟时间小于 40ms 的数据
  - **交互分组机制**
    - 浏览器会将逻辑上属于同一交互的多个事件分配相同或连续的interactionId
    - 例如，一次点击产生的多个事件（pointerdown, pointerup, click）被视为一个交互
  - INP 不统计所有交互的平均值，而是统计页面上“最慢的交互”
    - **最慢的交互**：精确来说是第98百分位的交互延迟，这意味着：
      - 在200次交互中，INP 是第4慢的交互
      - 在100次交互中，INP 是第2慢的交互
      - 在50次交互中，INP 是第1慢的交互
- 何时上报？
  - 交互发生时计算到了“最慢的交互”，此时「尝试上报」
  - 页面隐藏时，此时「强制上报」
  - 从 `bfcache` 返回后，重置指标、交互记录，此时「准备上报」（不调用上报方法，但是给上报方法赋值便于下次调用）
