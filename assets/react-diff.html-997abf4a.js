import{_ as e,p as l,q as i,Y as n}from"./framework-aa5c4115.js";const c="/singleNodeDiff.jpg",o="/arrayNodeDiff.jpg",d={},a=n(`<h2 id="整体流程" tabindex="-1"><a class="header-anchor" href="#整体流程" aria-hidden="true">#</a> 整体流程</h2><p>全部逻辑都在 <code>reconcileChildren(current, workInProgress, nextChildren, renderLanes)</code> 方法中</p><p>下面对于它的入参进行解释：</p><ul><li><code>current</code> 当前节点（页面中已经展示的 DOM），初次渲染为 <code>null</code></li><li><code>workInProgress</code> 工作节点（当前正在进行中的节点）</li><li><code>nextChildren</code> 子元素节点 <ul><li>例如：<div><p>hello</p></div>，div 节点为工作节点时 p 节点就为他的 <code>nextChildren</code></li></ul></li><li><code>renderLanes</code> 优先级相关</li></ul><p>而这个方法中又细分初次渲染和更新方法：</p><ul><li>初次渲染：<code>mountChildFibers(workInProgress, null, nextChildren, renderLanes)</code></li><li>更新：<code>reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes)</code></li><li>其实都指向：<code>reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes)</code></li></ul><p>可以看到他们的入参很相近，其实底层方法也是一样的，只不过内部会有一些不同的处理，还是老规矩，分析入参：</p><ul><li><code>returnFiber</code> 保持单链表节点的结构</li><li><code>currentFirstChild</code> 这里就是初次渲染和更新最大的不同，因为更新涉及到节点的复用</li><li><code>newChild</code> 同上</li><li><code>lanes</code> 优先级相关</li></ul><p>入参分析到此为止，下面进入真正的 Diff 逻辑。</p><ol><li>首先是对 <code>Fragment</code> 节点（&lt;&gt;&lt;/&gt;）进行处理，如果是该节点直接拿他的子节点</li><li>判断节点的类型</li></ol><ul><li><code>typof ==&gt; &#39;object&#39;</code>，该逻辑比较复杂，分为单节点 Diff 和多节点 Diff</li><li><code>typeof ==&gt; &#39;string&#39;</code>，当作单节点处理 <code>TextNode</code></li><li><code>typeof ==&gt; &#39;function&#39;</code>，发出警告</li></ul><ol start="3"><li>以上类型都不是就直接标记删除</li></ol><h2 id="单节点-diff" tabindex="-1"><a class="header-anchor" href="#单节点-diff" aria-hidden="true">#</a> 单节点 Diff</h2><p>处理三种情况：</p><ul><li><p>类型为 <code>element</code></p><ul><li><code>reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes)</code></li><li>先判断是否是初次渲染（<code>while(currentFirstChild !== null)</code>） <ul><li>初次渲染就跳过/不存在 <code>currentFirstChild</code> 也跳过</li><li>不是初次渲染就走该逻辑</li><li>判断 <code>key</code> 是否相同 <ul><li>不同的话就直接删除子节点（<code>currentFirstChild</code>）</li><li>相同的话就继续走该逻辑，判断 <code>type</code> 是否相同 <ul><li>不同的话就连它与它的子节点直接全部删除</li><li>相同的话就删除该节点的兄弟节点，复用该节点，返回该节点，退出逻辑 🔚</li></ul></li></ul></li><li>赋值子节点为它的兄弟节点（<code>currentFirstChild = currentFirstChild.sibling</code>），继续上面的逻辑👆（注意这里的处理与 <code>key</code> 相同但 <code>type</code> 不同的处理逻辑不同）</li></ul></li><li>根据 <code>newChild</code> 的类型，创建对应节点，返回该节点，退出逻辑 🔚</li></ul></li><li><p>类型为 <code>portal</code></p><ul><li>与上面的逻辑类似</li></ul></li><li><p>类型为 <code>lazy</code></p><ul><li>执行下面逻辑</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token keyword">var</span> payload <span class="token operator">=</span> newChild<span class="token punctuation">.</span>_payload<span class="token punctuation">;</span>
  <span class="token keyword">var</span> init <span class="token operator">=</span> newChild<span class="token punctuation">.</span>_init<span class="token punctuation">;</span> <span class="token comment">// TODO: This function is supposed to be non-recursive.</span>

  <span class="token keyword">return</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> <span class="token function">init</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>不是这三种类型的话就接着继续判断是否多节点</p></li></ul><p>流程图如下：</p><p><img src="`+c+'" alt="singleNodeDiff"></p><h2 id="多节点-diff" tabindex="-1"><a class="header-anchor" href="#多节点-diff" aria-hidden="true">#</a> 多节点 Diff</h2><p>源码中的方法为：<code>reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes)</code></p><ul><li>先校验 <code>key</code></li><li>然后处理更新的情况 <ul><li><code>key</code> 不同，直接跳过本次循环</li><li><code>key</code> 相同 <ul><li><code>type</code> 不同，表示无法复用，需要创建新节点</li><li><code>type</code> 相同，表示可以复用，直接复用</li></ul></li></ul></li><li>再处理新增（老节点无法复用）的情况 <ul><li>如果没有老节点的话就直接创建新节点</li></ul></li><li>最后如果新节点还未处理完的话再将老节点未被删除（标记为删除）的节点集合为 Map 数据，从中找到可以复用的节点 <ul><li>因为 <code>key</code> 不同跳出第一次循环会导致新节点没被处理完，那就需要考虑移动复用节点的情况了</li><li>React 的处理是将所有的旧节点重新 push，举个例子： <ul><li>假如列表为 1-&gt;2-&gt;3，我们更新后变为 3-&gt;1-&gt;2； <ul><li>看起来是将 3 移动到最前面，实际上是 3 不动，依次向后面添加 1 与 2</li></ul></li><li>同理如果列表从 1-&gt;2-&gt;3 变为 1-&gt;3-&gt;2 <ul><li>那么就是 1 与 3 不动，只将 2 添加到 3 后面就好了</li></ul></li></ul></li></ul></li></ul><p>流程图如下：</p><p><img src="'+o+'" alt="arrayNodeDiff"></p><h2 id="疑问🤔" tabindex="-1"><a class="header-anchor" href="#疑问🤔" aria-hidden="true">#</a> 疑问🤔</h2><ul><li><code>lazy</code> 的组件 <code>_palyload</code> 和 <code>_init</code> 是什么？</li></ul>',24),s=[a];function t(r,p){return l(),i("div",null,s)}const h=e(d,[["render",t],["__file","react-diff.html.vue"]]);export{h as default};
