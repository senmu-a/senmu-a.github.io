import{_ as e,p as a,q as i,Y as d}from"./framework-aa5c4115.js";const o={},c=d('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><p>在随着项目的发展，我们的应用也会随之变得越来越巨大，那么对于项目的维护也会变得巨复杂。</p><p>而微前端方案可以将众多子应用拆分，独立部署，并且不限于技术栈，最终在主应用（基座）中展现。</p><h2 id="微前端方案" tabindex="-1"><a class="header-anchor" href="#微前端方案" aria-hidden="true">#</a> 微前端方案</h2><h3 id="iframe" tabindex="-1"><a class="header-anchor" href="#iframe" aria-hidden="true">#</a> iframe</h3><p>通信不方便，路由同步问题等影响用户体验。</p><h3 id="路由分发-前端集成方案" tabindex="-1"><a class="header-anchor" href="#路由分发-前端集成方案" aria-hidden="true">#</a> 路由分发（前端集成方案）</h3><p>通过访问不同路由来加载不同子应用</p><h3 id="基于-web-components" tabindex="-1"><a class="header-anchor" href="#基于-web-components" aria-hidden="true">#</a> 基于 web components</h3><p>隔离性很好！！！</p><p>但不同框架的 Web Components 兼容性可能有问题。</p><h3 id="webpack5-模块联邦" tabindex="-1"><a class="header-anchor" href="#webpack5-模块联邦" aria-hidden="true">#</a> Webpack5 模块联邦</h3><p>适用于共享组件库等代码的场景，相比 <code>qiankun</code> 的方案：</p><ul><li>代码仓库：他们都可以独立拆分不同项目进行独立部署</li><li>加载方式： <ul><li>模块联邦：运行时按需加载</li><li><code>qiankun</code>：运行时加载整个子应用</li></ul></li><li>共享依赖： <ul><li>模块联邦：可以共享依赖</li><li><code>qiankun</code>：个子应用独立运行，可能会重复加载</li></ul></li><li>通信方式： <ul><li>模块联邦：直接 <code>import()</code> 远程模块</li><li><code>qiankun</code>：<code>window.postMessage</code></li></ul></li></ul><h3 id="qiankun" tabindex="-1"><a class="header-anchor" href="#qiankun" aria-hidden="true">#</a> qiankun</h3><p>基于 <code>single-spa</code> 来实现的微前端解决方案，内部封装了沙箱、通信。</p><h4 id="沙箱" tabindex="-1"><a class="header-anchor" href="#沙箱" aria-hidden="true">#</a> 沙箱</h4><p>主要是解决了多个子应用全局变量的污染问题、css 样式冲突等问题。</p><ul><li><code>window</code> 污染问题：通过 <code>Proxy</code> 代理子应用的 <code>window</code><ul><li>如果浏览器不支持 <code>Proxy</code> 可以利用一个空的 iframe 来劫持子应用的 <code>window</code> 然后再通过 <code>postmessage</code> 与主应用通信即可。</li></ul></li><li>css 样式隔离：css-scoped、shadow-dom</li></ul><h4 id="通信" tabindex="-1"><a class="header-anchor" href="#通信" aria-hidden="true">#</a> 通信</h4><ul><li>父子应用之间通信：<code>initGlobalState</code>、<code>props</code> 的方式</li><li>兄弟应用之间通信： <ul><li>可以使用事件订阅的方式通信，需要通过父应用实现事件总线，然后挂载到 <code>window</code> 中</li><li>还有 <code>localstorage</code></li></ul></li></ul>',21),l=[c];function n(r,h){return a(),i("div",null,l)}const t=e(o,[["render",n],["__file","micro-frontend.html.vue"]]);export{t as default};
