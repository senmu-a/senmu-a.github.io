import{_ as n,p as r,q as c,s as e,R as l,t as o,Y as t,n as d}from"./framework-aa5c4115.js";const a={},s=t('<h2 id="什么是性能监控" tabindex="-1"><a class="header-anchor" href="#什么是性能监控" aria-hidden="true">#</a> 什么是性能监控？</h2><p>性能监控简单来说就是通过一个 SDK 进行零负担的监测网站运行的性能情况以及报错等等。</p><h2 id="为什么要做性能监控" tabindex="-1"><a class="header-anchor" href="#为什么要做性能监控" aria-hidden="true">#</a> 为什么要做性能监控？</h2><p>性能监控旨在收集网页的性能信息，然后分析信息进行改进提升，最终提升用户留存率等等。</p><h2 id="怎样做性能监控" tabindex="-1"><a class="header-anchor" href="#怎样做性能监控" aria-hidden="true">#</a> 怎样做性能监控？</h2><ol><li>定好需要统计的指标，例如（FP、FCP、CLS、INP等）</li><li>写一个 SDK 进行指标的统计、收集、上报 <ol><li>可以参考 <code>web-vitals</code> 库</li><li>注意做好兜底等边缘情况</li><li>注意性能问题</li></ol></li><li>建设/使用第三方成熟的数据处理平台进行数据的维护 <ol><li>收集数据</li><li>清洗脏数据，但是注意不要丢掉，单独存放进行分析是否有价值</li><li>存储正常数据</li><li>通过监控平台展示</li></ol></li></ol>',6),h={href:"https://github.com/rrweb-io/rrweb?tab=readme-ov-file",target:"_blank",rel:"noopener noreferrer"},u=e("code",null,"rrweb",-1),p=e("h2",{id:"fcp-首次有内容的绘制-指标",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#fcp-首次有内容的绘制-指标","aria-hidden":"true"},"#"),l(" FCP（首次有内容的绘制）指标")],-1),_=e("p",null,"核心部分",-1),f={href:"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"PerformanceObserver",-1),P=t("<li>监测 <code>paint</code><ul><li>对于 FCP，<code>entry.name</code> 为 <code>first-contentful-paint</code></li><li>对于 FP，<code>entry.name</code> 为 <code>first-paint</code></li></ul></li><li>计算指标</li><li>上报</li>",3),g=t("<li><p>处理边缘情况</p><ul><li>预渲染</li><li>页面是 <code>hidden</code> 状态</li><li>bfCache</li></ul></li><li><p>测量什么？(<code>value = FCP 事件发生的时间点 - 页面激活的时间点</code>)</p><ul><li>预渲染：「页面激活的时间点（<code>activationStart</code>）」是用户实际导航到页面的时刻 <ul><li>时间 0ms：浏览器开始在后台预渲染页面 A</li><li>时间 2000ms：预渲染完成，页面在后台准备就绪</li><li>时间 5000ms：用户点击链接，导航到页面 A（此时 <code>activationStart</code> = 5000ms）</li><li>时间 5100ms：首次内容绘制 (FCP) 发生</li><li>结果：5100 - 5000 = 100</li></ul></li><li>非预渲染：等于 0（即导航开始时间）</li></ul></li><li><p>如何上报？</p><ul><li>页面非 <code>hidden</code> 状态，「强制上报」</li><li>从 <code>bfcache</code> 返回，重新计算，「强制上报」</li></ul></li>",3),m=e("h2",{id:"lcp-最大内容的绘制-指标",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#lcp-最大内容的绘制-指标","aria-hidden":"true"},"#"),l(" LCP（最大内容的绘制）指标")],-1),C=e("p",null,"其实懂了上面的 FCP 这个指标也很容易理解，核心就三个步骤：",-1),v=e("code",null,"handleEntries",-1),x=e("code",null,"entries",-1),I={href:"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"entries",-1),S={href:"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType",target:"_blank",rel:"noopener noreferrer"},F=e("li",null,[l("使用 "),e("code",null,"PerformanceObserver"),l(" 监测 "),e("code",null,"largest-contentful-paint")],-1),N=e("li",null,"处理好边缘情况，上报数据",-1),A=t('<p>与 FCP 不同的是，LCP 是一个多次采集的过程，终止条件在用户与页面发生交互或者页面 <code>hidden</code> 的情况，这时才会上报 LCP 统计的数据。</p><ul><li>测量什么？（<code>value = LCP 事件发生的时间点 - 页面激活的时间点</code>） <ul><li>与 FCP 类似</li></ul></li><li>何时上报？ <ul><li>页面非 <code>hidden</code> 状态，「尝试上报」</li><li>页面发生了状态改变并且为 <code>hidden</code> 状态，「强制上报」</li><li>发生了用户交互，「强制上报」</li><li>从 <code>bfcache</code> 返回，重新计算，「强制上报」</li></ul></li></ul><h2 id="cls-累积偏移量-指标" tabindex="-1"><a class="header-anchor" href="#cls-累积偏移量-指标" aria-hidden="true">#</a> CLS（累积偏移量）指标</h2><blockquote><p>监测 <code>layout-shift</code></p></blockquote><p>流程就不赘述了，来说下值得关注的部分：</p><ol><li>必须发生在 <code>onFCP</code> 之后 <ol><li>符合 <code>CrUX</code> 标准</li><li>更加符合用户体验</li><li>减少噪音</li></ol></li><li>使用「会话窗口」的算法来计算 CLS <ol><li><strong>分组</strong>：把时间上接近的布局偏移归为一组（窗口）</li><li><strong>计时</strong>：一个窗口的总时长不超过5秒，相邻偏移间隔不超过1秒</li><li><strong>取最大值</strong>：最终报告所有窗口中分数最高的那个</li></ol></li><li>何时上报？ <ol><li>当前「会话窗口」累计的偏移量大于前面累计的最大偏移量「尝试上报」（如果没有设置<code>reportAllChanges</code>为<code>true</code>也不会上报） <ol><li>聚焦最差的</li></ol></li><li>页面是 <code>hidden</code> 状态，「强制上报」（不管是否设置<code>reportAllChanges</code>都会上报）</li><li><code>bfcache</code> 之后「尝试上报」（如果没有设置<code>reportAllChanges</code>为<code>true</code>也不会上报）</li><li>最后，就算没有满足以上条件也「尝试上报」（如果没有设置<code>reportAllChanges</code>为<code>true</code>也不会上报）</li></ol></li></ol><h2 id="ttfb-首字节返回时间-指标" tabindex="-1"><a class="header-anchor" href="#ttfb-首字节返回时间-指标" aria-hidden="true">#</a> TTFB（首字节返回时间）指标</h2><blockquote><p>从点击链接到服务器开始发送响应需要多长时间？</p></blockquote><ul><li>测量什么？ <ul><li><code>TTFB = responseStart - activationStart</code></li></ul></li><li>何时上报？ <ul><li>统计到第一个请求返回，立马强制上报</li><li><code>bfcache</code> 之后，重制指标值，强制上报（因为从 <code>bfcache</code> 返回，无需请求接口，所以直接上报 0）</li></ul></li></ul><h2 id="inp-interaction-to-next-paint-指标" tabindex="-1"><a class="header-anchor" href="#inp-interaction-to-next-paint-指标" aria-hidden="true">#</a> INP（Interaction to Next Paint）指标</h2><blockquote><p>发生交互到下次绘制的时间</p></blockquote><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>INP 跟踪用户的点击、触摸和按键交互，保留最慢的10个交互作为候选，然后从中选择一个统计上显著的值（通常是第98百分位）作为最终指标。 这个值代表了页面响应用户交互的最差情况，同时排除了极端异常值的影响。</p><ul><li>测量什么？ <ul><li><code>交互延迟 = 输入处理时间 + 事件处理时间 + 渲染更新时间</code><ul><li><strong>输入处理</strong>：浏览器处理原始输入事件（点击、按键等）</li><li><strong>事件处理</strong>：JavaScript 执行相应的事件处理程序</li><li><strong>渲染更新</strong>：浏览器计算布局、绘制并显示更新后的内容</li></ul></li><li>过滤掉延迟时间小于 40ms 的数据</li><li><strong>交互分组机制</strong><ul><li>浏览器会将逻辑上属于同一交互的多个事件分配相同或连续的interactionId</li><li>例如，一次点击产生的多个事件（pointerdown, pointerup, click）被视为一个交互</li></ul></li><li>INP 不统计所有交互的平均值，而是统计页面上“最慢的交互” <ul><li><strong>最慢的交互</strong>：精确来说是第98百分位的交互延迟，这意味着： <ul><li>在200次交互中，INP 是第4慢的交互</li><li>在100次交互中，INP 是第2慢的交互</li><li>在50次交互中，INP 是第1慢的交互</li></ul></li></ul></li></ul></li><li>何时上报？ <ul><li>交互发生时计算到了“最慢的交互”，此时「尝试上报」</li><li>页面隐藏时，此时「强制上报」</li><li>从 <code>bfcache</code> 返回后，重置指标、交互记录，此时「准备上报」（不调用上报方法，但是给上报方法赋值便于下次调用）</li></ul></li></ul>',14);function y(L,q){const i=d("ExternalLinkIcon");return r(),c("div",null,[s,e("p",null,[l("如果要做错误等回放功能，可以考虑 "),e("a",h,[u,o(i)])]),p,e("ul",null,[e("li",null,[_,e("ul",null,[e("li",null,[l("利用 "),e("a",f,[b,o(i)]),l(" API")]),P])]),g]),m,C,e("ol",null,[e("li",null,[l("创建 "),v,l(" 方法来处理 "),x,e("ol",null,[e("li",null,[e("a",I,[l("什么是 "),k,l("？"),o(i)])]),e("li",null,[e("a",S,[l("https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType"),o(i)])])])]),F,N]),A])}const E=n(a,[["render",y],["__file","webMoniter.html.vue"]]);export{E as default};
